# The STV Rogue Project

This provides an initial implementation of the logical game entities of STV Rogue.
Some methods are left unimplemented for you. You can extend the project, but
please stick to the imposed architecture and keep the signatures of the current
methods.

The project contains the following directories:
   * `src`:  the source files, in Java
   * `test`: here you can find few examples of unit tests

In Java the names of packages are reflected in the directory path. For example
the class `C` of the package `X.Y.Z` would reside in the path `src/X/Y/Z`, and the source
file would be called `C.java`.

Some notable packages:
* `STVRogue.GameLogic` : this contains the game entities that you need to work out and test.
* `STVRogue.Examples`  : contain some example classes; these are not relevant for the game you implement. The examples are mainly used to demonstrate unit testing.
* `STVRogue.TestInfrastructure`: this contains classes relevant for Iteration-2. Ignore them for now.

Some notable classes:
* `STVRogue.HelperPredicates` contains some predicates you might want to borrow, e.g. to check if a zone forms a connected graph.
* `STVRogue.PathCoverageTracker` contains a utility to track coverage over a finite state machine. Check it out if you do Optional-1.
* `STVRogue.Utils` contains few utility methods, e.g. to create a pseudo-random generator.


## Use Eclipse instead of VS

Since you will be developing in Java, the easiest IDE to get you started is Eclipse. Once you have Eclipse, install the EclEmma plugin to help you track the code coverage of your unit tests.


## Which unit testing framework to use?

JUnit. It should already be part of your Eclipse install.


## Automated Testing (an optional part of your project)

Among professionals, _Automated Testing_ usually mean automating the execution of your tests.
Here I mean something stronger, namely automatically generating your test inputs, or even test
sequences. Unfortunately, test oracles cannot be generated by a machine, since machines
cannot read our mind, so they have no clue what the intended definition of correctness
of a given program is.

Automated generation of test inputs is however possible. As oracles, it makes sense to use
so-called _properties_, which are predicates.

You can always build your own automated testing infrastructure, custom made for
the program at hand. There is also this tool called T3
(https://git.science.uu.nl/prase101/t3/wikis/home)
which can do that for you. T3 belongs to the family of random testing tool, like QuickCheck. However, since Java is an OO language, T3 does a bit more. Given a target class C to test, it generates random sequences of calls to C's methods, and passing to them randomly generated inputs. Random testing tools are usually fast and easy to use, however you also can't expect them to perform well
for generating inputs with very specific formats, e.g. valid email addresses.
However, T3 allows you to write custom generators to get
around this problem.

We won't have any lecture on how to use tool-X; it is part of your optional fun
to study its documentation and discover it on your own how to use it.
I won't spoil the fun :)
Besides, the lectures are to be used to focus more on the underlying concepts.

## Mutation Tests (an optional part of your project)

Mutation test is NOT a test against your System Under Test. Instead, it is
a test to measure the strength of your test suite, so it is also quite useful.
In fact, it should actually be a standard tool to support unit testing.
There are fortunately a number of mutation testing tools for Java.
We will use Pitest (http://pitest.org/).
It's fun to do, and would be a useful experience too.
